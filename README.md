# BomberMan
[TOC]

# 1. 引言

本次开发的是一个炸弹人对战游戏， 游戏名称为Bomber Man， 用户界面用GUI实现，并使用网络编程，支持多组用户同时对战。玩家通过在地图上释放炸弹来攻击对手，每局游戏只要对方被炸弹炸到一次就判定敌负我胜。通过本项目的开发，对Java语言的各项功能有了更深的理解，并掌握了利用这些功能特性来编程的方法，提高了自己的编程水平。

## 1.1. 设计目的

炸弹人是一个非常有意思的游戏，类似于盛大的泡泡堂、腾讯的QQ堂，都是通过在地图上释放炸弹攻击对方来实现对战效果， 当然这些上线多年的游戏还有BOSS模式、 探险模式，更支持多地图、多人物， 界面也是精美的Q版画面， 而Bomber Man只实现了简单的双人对战， 而且地图和人物暂时也比较单调。主要功能描述如下：

1. BomberMan采用C/S架构，在Server端使用了JDBC访问数据库保存用户的用户名及密码的信息，所以用户可以进行登录或注册的操作。
2. 用户可以选择创建对战或加入对战。
3. 在选择创建/加入对战的界面，用户可以选择登出，然后可以继续选择登录或注册。 
4. 游戏过程中玩家通过方向键控制人物形象移动、通过空格键释放炸弹。
5. 游戏过程中能够使对方被炸弹炸到则此局游戏结束，系统会有相应提示。

## 1.2. 设计说明

本项目采用Java程序设计语言编程，在IntelliJ IDEA平台下编辑、编译与调试。

- JRE版本： 1.8.0_112-release-408-b6 x86_64
- IntelliJ IDEA版本：2016.3.2


# 2. 总体设计

## 2.1. 功能模块设计

本程序实现的主要功能有：

1. 玩家可以选择注册一个用户或使用用户名和密码登录，如果用户名和其他用户重复、密码错误，或这个用户已经在线，则会有登录/注册失败的相应提醒。
2. 玩家可以选择创建对战或加入对战。如果选择创建对战，服务端会将此玩家加入创建对战的等待队列；如果选择加入对战，服务端会将此玩家匹配到最先进入创建对战等待队列的那一个玩家进行对战，如果当前等待队列为空，游戏会有不能加入对战的提示。
3. 游戏过程中，玩家通过方向键控制人物形象移动，通过空格键释放炸弹。 在程序的常量定义类中规定：每个玩家最多只能释放5个炸弹，如果已经释放了5个炸弹，则需要等炸弹爆炸完毕之后才可以再次释放；每个炸弹的爆炸范围是上下左右四个方向的5个格子，如果爆炸范围内有其他炸弹则会一起爆炸。
4. 玩家如果被炸弹炸到，就会提示输掉了此局游戏，而对方也会提示此局胜利，同时游戏界面会消失，玩家回到选择创建对战、加入对战或注销的界面。
5. 每局游戏开始前，玩家可以选择注销。在游戏过程中也可以强行关闭程序，服务端会实现用户的下线，也会提醒对战玩家因为对手退出而结束游戏。

## 2.2. 流程图设计

程序的总体功能及流程：

![FlowchartDiagram1](/Users/positif/Library/Mobile Documents/com~apple~CloudDocs/其他/1617秋冬/Java应用技术/homework/HW4-BomberMan/图/6.png)

# 3. 详细设计

## 3.1. 系统选择窗口的设计

系统选择窗口的整体布局为GridBagLayout 布局, 使用了Button、Label 、JTextField、JPasswordField、JOptionPane等组件。

以下是选择窗口的相关java class的设计：

1. StartFrame：游戏的选择界面窗体，一开始只显示登录或注册时输入用户名、密码、服务器地址的输入框和相应按钮，如果用户登录成功则隐藏这些组件，显示选择创建/加入游戏/注销的按钮。如果用户注销，则隐藏三个按钮，显示这些组件，实现同一个窗口不同时刻的不同布局。在这个窗体添加诸多监听器，在登录/注册界面，只有用户名、密码、服务器三个输入框都不为空，登录和注册的按钮才可用。而所有按钮的监听都对应PairClient类中与服务器的交互操作，此类的生命周期为整个程序的生命周期。
2. PairClient：能够通过Socket连接服务器，并向服务器发送登录、注册、匹配对手、注销等请求的类，同时也接收服务器的响应从而发送结果至StartFrame进行各种UI提示。此类的生命周期为某一用户的登录/注册至用户注销。

## 3.2. 游戏窗口的设计

而游戏窗口BombermanFrame为简单的FlowLayout布局，只有自定义的GamePanel一个组件，进行游戏界面的绘制。其中根据面向对象的编程思想，游戏人物、背景墙、炸弹、正在爆炸的区域都作为对象，由GamePanel来管控，并在继承自JPanel的paintComponent(Graphics graphics)的方法中统一调用这些对象的draw方法来绘制。BombermanFrame的生命周期为每局游戏开始至结束，以下是游戏各组件的介绍：

1. Background：游戏的背景地图。 目前本项目只支持一种地图，就定义在Background类的初始化内容里。这个类的核心成员变量是boolean类型的isWall二维数组，如果该位置是墙则为true，不是墙则为false。规定人物移动的范围和炸弹爆炸的范围不能超过墙和游戏地图的范围。
2. Bombs：游戏当前的所有炸弹。会用int类型的bombsPosition记录每个位置是否有炸弹，如果有的话是玩家1还是玩家2释放的（因为每个玩家能够释放最多炸弹的数量是确定的，所以每次炸弹爆炸需要对这个炸弹的释放者当前已经释放的炸弹数量做更新修改）
3. Bombing：游戏当前的炸弹爆炸范围。会用boolean类型的bombingPosition记录每个位置是否正在爆炸。这个类由BombThread控制，通过调用GamePanel的addBombing()、removeBombing()方法进行控制。
4. Figure：当前玩家和对战玩家。用playerType来区分，分配不同的颜色（1号玩家粉红色，位置为（0，0）；2号玩家蓝绿色，位置为（480，0））。同时用bombsNum记录每个玩家当前已经释放的炸弹数目，防止超过限定的最大数目5。

另外游戏的运行周期内采用多线程编程，有如下几个线程：

1. BombThread：控制每个炸弹爆炸的线程。当玩家释放一个炸弹，这个线程就被创建并初始化，开始运行，休眠3000毫秒以后修改Bombs对象移除一个炸弹，再开始寻找爆炸范围，如果爆炸范围内有其他炸弹，就递归继续寻找爆炸范围。爆炸范围确定以后，修改Bombing对象并刷新绘制爆炸场景，最后线程结束。这个线程的生命周期是从每个炸弹被释放到爆炸完毕结束。
2. ClientReceiveThread：游戏过程中接收服务端信号的线程，因为接收过程调用BufferReader的readline方法会造成阻塞，所以特意多设一个线程专门用来接收信号并调用BombermanFrame的方法进行相应处理。
3. RivalFigureMoveThread：控制对战玩家移动的线程，使用movelock来等待允许移动的信号，这个信号由ClientReceiveThread收到服务端信号后调用BombermanFrame中的rivalMove方法给出。
4. ThisFigureMoveThread：控制本玩家移动的线程，使用movelock（和RivalFigureMove中的不是同一个movelock）来等待允许移动的信号，这个信号由BombermanFrame监听到键盘方向键按下后给出。和RivalFigureMoveThread区分开的另一特点是这个线程的成员函数还有一个PrintWriter成员变量，用以每次移动都向服务器发送移动的信号、每次停止都向服务器发送停止的信号。

## 3.3. 游戏服务器的设计

游戏服务器的全部代码写在一个BomberManServer.java文件里，通过调用各种成员函数和成员类来实现全部功能。工程使用了sqlite-jdbc-3.15.1依赖包来连接数据库，这是一个轻量级的数据库实现，如果运行此服务器程序的电脑上没有装MySQL也能够运行此服务器，因为依赖SQLite就可以把数据库内的所有信息存在bomberman.db文件里，而不需要连接本地MySQL数据库，同样地，在不同电脑间BomberMan用户数据库的迁移只需要传递这一个文件就可以了。

成员函数：

1. BomberManServer：构造函数，用以打开ServerSocket、初始化ExecutorService、调用databaseInitial()方法初始化数据库、调用acceptClient()方法接收客户端的连接。
2. databaseInitial：连接org.sqlite.JDB类中的jdbc:sqlite:bomberman.db数据库，如果数据库不存在就创建数据库，如果表不存在就创建表（如果表已经创建好了，创建表的操作就会截获到异常，相当于略过创建表的步骤直接后续操作）
3. acceptClient：接收客户端的连接，如果是注册用户就访问数据库核对后插入数据，如果是登录用户就访问数据库核对用户名密码是否一致并将结果发送给客户端。如果确认成功登录就调用ready()方法。
4. ready：创建并初始化BomberManClient类，将其加入ExecutorService运行。
5. connect：连接数据库。
6. dispose：关闭和数据库的连接，使修改生效。

成员类：

1. BomberManClient：实现了Runnable接口，接收客户端创建对战/加入对战/注销的请求。如果是创建对战，就加入创建对战的等待队列，生命周期结束；如果是加入对战，就匹配到创建对战的等待队列，并创建并初始化Fight类，将其加入ExecutorService运行；如果队列为空就返回错误信号，然后继续接收请求；如果是注销，就从当前在线的unameSocketMap中除去，这个类的生命周期结束。
2. Fight：实现了Runnable接口，成为两个客户端游戏过程中信息交流的桥梁，为了避免阻塞，创建并运行两个线程分别接受两个客户端的信息并进行信息交互。如果收到某一个客户端游戏人物被炸弹炸到的信息或离开游戏的信息，就结束这两个线程， 并使用两个客户端的用户名调用ready方法继续接受请求，最后结束自己的生命周期。

# 4. 测试与运行

## 4.1. 程序测试

通过编程和不断的调试、修改，最后BomberMan能够正常运行，预期功能都得到了实现。虽然游戏组件都设计为非常简单的不同颜色圆形、圆角矩形、矩形进行绘制，但一系列游戏功能都没有受到影响，如果后期有时间还可以利用一些UI素材、游戏场景素材进行进一步的优化。

## 4.2. 程序运行

![6](http://ww3.sinaimg.cn/large/006tNc79gy1ffimlv5g33j31400scgmk.jpg)

 ![7](http://ww4.sinaimg.cn/large/006tNc79gy1ffimmavce3j31400sct9o.jpg)



# 5. 总结

1. BomberMan项目的编程过程中不可避免地遇到了许多问题，但是通过不断调试，锻炼了自己的调试能力，还有加深了对java编程中许多细节的理解。对一些问题的处理如下。
2. 本来ThisFigureMoveThread和RivalFigureMoveThread的生命周期是准备设置成人物的每次移动到停止的，这样方向键按下时初始化一次，方向键松开时线程结束，但是发现长按之后会有非常多的线程产生，而不是预期的每次只有一个，就算利用一些状态变量来限制还是没法解决问题。所以就改为设置ThisFigureMoveThread和RivalFigureMoveThread线程全程执行，每次人物移动完毕之后就利用moveLock.wait()来等待下次移动的信号。
3. 本来开启ClientReceiveThread后，游戏选择界面的窗口被会被其阻塞，所以改成了使用ExecutorService，这样就可以和UI完全分离开，避免阻塞了
4. 因为在在编程、调试和性能优化的过程中，总是把很多代码从一个类移到另一个，所以把常量都写在Constant类里非常方便，也不需要改常量的位置。
5. 调试的时候发现Socket使用BufferReader的readline方法容易阻塞，只是把stop赋值为true根本没法停止线程，就算用interrupt也不行，所以最后的解决办法是，客户端发送一行空字符串，这样服务器就可以结束阻塞状态，成功结束循环。
6. 游戏基本功能实现以后进行测试，发现在第二次加入游戏的时候收不到游戏开始的信息，花了很长时间调试也没有找到问题，最后发现是没有关闭游戏过程中的ClientReceiveThread导致游戏开始的信息被其接收。
7. 另外，因为网络延迟等原因，对手的路径总是容易发生偏差，所以设定每次移动停止后发送本玩家的当前位置至服务器，这样对方就可以收到本玩家最终停止的位置，实现位置同步。

# 6. 参考文献

 [1] Y. Daniel Liang．Java语言程序设计．机械工业出版社，2011.5
